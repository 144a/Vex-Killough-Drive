#pragma config(Sensor, dgtl5,  frontRight,     sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  frontRight,     sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  backRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, backLeft,       sensorQuadEncoder)
#pragma config(Motor,  port2,           frontRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           backRight,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           backLeft,      tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int const TICKIN = 127;
int const TICKOUT = 127;

// do I even need a comment for this
void zeroEncoders() {
	SensorValue[frontRight] = 0;
	SensorValue[frontLeft] = 0;
	SensorValue[backRight] = 0;
	SensorValue[backLeft] = 0;
}

void zeroMotors() {
	motor[frontRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
	motor[backRight] = 0;
}

// time-based drive function. Will drift depending on individual motor speeds
// written assuming "dur" is in milliseconds
void driveNTime(float ix, float iy, float iw, int dur) {

  // x axis directional control
	float x = vexRT[Ch3] / TICKIN;

	// y axis diredtional control
	float y = vexRT[Ch3] / TICKIN;

	// rotational control
	float w = vexRT[Ch3] / TICKIN;

	// individal wheel speed calculation; refer to main loop
	motor[frontRight] = (-0.35 * x + 0.35 * y + 0.25 * w) * TICKOUT;
	motor[frontLeft] = (-0.35 * x + -0.35 * y + 0.25 * w) * TICKOUT;
	motor[backLeft] = (0.35 * x + -0.35 * y + 0.25 * w) * TICKOUT;
	motor[backRight] = (0.35 * x + 0.35 * y + 0.25 * w) * TICKOUT;

	// clears timer
	ClearTimer(T1);

	// waits for a duration of time
	while(time1[T1] <= dur) {}

	zeroMotors();
}




void autonomous() {



}

task main()
{
	// x axis directional control
	float x = vexRT[Ch3] / TICKIN;

	// y axis diredtional control
	float y = vexRT[Ch3] / TICKIN;

	// rotational control
	float w = vexRT[Ch3] / TICKIN;

	// uses pre-calculated table of values when solving for the speeds
	//
	//      [[-0.35, 0.35, 0.25]       [[x]        [[s1]
	//       [-0.35, -0.35, 0.25]   *   [y]    =    [s2]
	//       [0.35, -0.35, 0.25]        [w]]        [s3]
	//       [0.35, 0.35, 0.25]]                    [s4]]
	//
	// s1 = front right, s2 = front left, s3 = back left, s4 = back right
	float s1 = (-0.35 * x + 0.35 * y + 0.25 * w) * TICKOUT;
	float s2 = (-0.35 * x + -0.35 * y + 0.25 * w) * TICKOUT;
	float s3 = (0.35 * x + -0.35 * y + 0.25 * w) * TICKOUT;
	float s1 = (0.35 * x + 0.35 * y + 0.25 * w) * TICKOUT;

	// set all motors to respective speeds
	motor[frontRight] = s1;
	motor[frontLeft] = s2;
	motor[backLeft] = s3;
	motor[backRight] = s4;
}
